<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hexo相关问题解决</title>
      <link href="/2020/06/13/mehe/"/>
      <url>/2020/06/13/mehe/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo相关问题解决"><a href="#hexo相关问题解决" class="headerlink" title="hexo相关问题解决"></a>hexo相关问题解决</h1><h2 id="博客插入图片（hexo使用markdown图片无法显示问题）"><a href="#博客插入图片（hexo使用markdown图片无法显示问题）" class="headerlink" title="博客插入图片（hexo使用markdown图片无法显示问题）"></a>博客插入图片（hexo使用markdown图片无法显示问题）</h2><p><code>hexo</code>默认无法自动处理文章插入本地图片，需要通过扩展插件支持</p><p>安装<a href="https://github.com/7ym0n/hexo-asset-image.git" target="_blank" rel="noopener">hexo-asset-image</a>，运行<code>hexo n "xxxx"</code>来生成md博文时，<code>/source/_posts</code>文件夹内除了xxxx.md文件还有一个同名的文件夹，把图片放入该文件夹。</p><p>使用<code>![xxx](xxx/xxx.png)</code>直接插入图片即可。</p><p>问题</p><p>由于hexo3版本后对很多插件支持有问题，<a href="https://github.com/CodeFalling/hexo-asset-image.git" target="_blank" rel="noopener">hexo-asset-image</a>插件在处理<code>data.permalink</code>链接时出现路径错误，把年月去掉了，导致最后生成的路径为<code>%d/xxx/xxx</code>需要对其做兼容处理。通过判断当前版本是否等于<code>3</code>的版本做不同的路径分割。</p><p>在代码中加入：</p><pre><code>var version = String(hexo.version).split('.');</code></pre><p>修改<code>date.permalink</code>处理：</p><pre><code>var link = data.permalink;  if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)     var beginPos = getPosition(link, '/', 1) + 1; else     var beginPos = getPosition(link, '/', 3) + 1;</code></pre><p>重新生成静态文件即可正确显示。</p><p>可直接安装已经修改过得插件<code>npm install https://github.com/7ym0n/hexo-asset-image --sa</code>。</p><p>作者：菜鸡_快递到了<br>链接：<a href="https://www.jianshu.com/p/3db6a61d3782" target="_blank" rel="noopener">https://www.jianshu.com/p/3db6a61d3782</a><br>来源：简书</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript</title>
      <link href="/2020/06/13/javascript/"/>
      <url>/2020/06/13/javascript/</url>
      
        <content type="html"><![CDATA[<p>开发中。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java</title>
      <link href="/2020/06/13/java/"/>
      <url>/2020/06/13/java/</url>
      
        <content type="html"><![CDATA[<p>开发中。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL启动问题解决</title>
      <link href="/2020/06/13/MySQL/"/>
      <url>/2020/06/13/MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL启动错误相关解决："><a href="#MySQL启动错误相关解决：" class="headerlink" title="MySQL启动错误相关解决："></a>MySQL启动错误相关解决：</h1><h2 id="MySQL错误：2003-Can’t-connect-to-MySQL-server-on-‘localhost’-10061-“unknown-error”"><a href="#MySQL错误：2003-Can’t-connect-to-MySQL-server-on-‘localhost’-10061-“unknown-error”" class="headerlink" title="MySQL错误：2003-Can’t connect to MySQL server on ‘localhost’(10061 “unknown error”)"></a>MySQL错误：2003-Can’t connect to MySQL server on ‘localhost’(10061 “unknown error”)</h2><h3 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h3><p>​       开启本地的MySQL服务，这样很容易就可以解决这个问题了。如果这样无法解决问题您可以再尝试一下第二种解决方案。</p><p><img src="/2020/06/13/MySQL/1.jpg" alt="MySQL"></p><h3 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h3><p>第二种解决方案是后来想到会不会是因为每一次卸载的时候没有彻底卸载干净，然后就彻彻底底卸载干净了再重装，然后就成功了！因为上一次安装的数据库在C盘的配置文件还存在，对后面安装时的配置文件产生了冲突，所有导致了这个问题。话不多说，直接上干货！</p><p>　　1）删除程序。进入控制面板-&gt;在程序和功能选项卡中找到MySQL，右键卸载。</p><p>　　2）删除安装文件夹下的所有内容。找到MySQL的安装路径，然后删除路径下所有文件。</p><p>　　3）删除注册表。Windows+R打开运行命令框，输入regedit回车，删除以下3个地方的注册文件：</p><p>　　　　HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\Application\MySQL 目录删除 </p><p>　　　　HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\Eventlog\Application\MySQL 目录删除 </p><p>　　　　HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Eventlog\Application\MySQL 目录删除</p><p>　　4）最重要的一点（我就是由于没有删除此文件而导致出错的）：进入C盘，选中查看-&gt;勾选“隐藏的项目”，然后下面就出来隐藏目录（ProgramData）了，进入其中，删除MySQL文件夹。</p><p>　　到此，你需要做的就只是重装一遍就行了！　　<br>————————————————<br>版权声明：本文为CSDN博主「努力的凹凸曼」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/py_123456/article/details/79694786" target="_blank" rel="noopener">https://blog.csdn.net/py_123456/article/details/79694786</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javaweb</title>
      <link href="/2020/06/12/Javaweb/"/>
      <url>/2020/06/12/Javaweb/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h1><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><h2 id="JSTL标签"><a href="#JSTL标签" class="headerlink" title="JSTL标签"></a>JSTL标签</h2><p>1.先导入 JSTL jar包</p><pre><code> taglibs-standard-impl-1.2.1.jar  taglibs-standard-spec-1.2.1.jar</code></pre><p>2.使用taglib指令引入标签库</p><pre><code>&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;</code></pre><p>core核心库使用：</p><p>i.  ‘&lt;c:set&gt;’（使用很少）</p><p>作用：set 标签可以往域中保存数据</p><pre><code>&lt;%--i.&lt;c:set /&gt;       作用：set 标签可以往域中保存数据       域对象.setAttribute(key,value);       scope 属性设置保存到哪个域       page 表示 PageContext 域（默认值）      request 表示 Request 域      session 表示 Session 域       application 表示 ServletContext 域       var 属性设置 key 是多少      value 属性设置值   --%&gt;   保存之前：${ sessionScope.abc } &lt;br&gt;   &lt;c:set scope="session" var="abc" value="abcValue"/&gt;      保存之后：${ sessionScope.abc } &lt;br&gt;</code></pre><p>ii.  <code>&lt;c:if/&gt;</code></p><pre><code>   if标签用来做if判断</code></pre><pre><code>&lt;%--       ii.&lt;c:if /&gt;          if 标签用来做 if 判断。           test 属性表示判断的条件（使用 EL 表达式输出） --%&gt;&lt;c:if test="${ 12 == 12 }"&gt;        &lt;h1&gt;12 等于 12&lt;/h1&gt;&lt;/c:if&gt;&lt;c:if test="${ 12 != 12 }"&gt;        &lt;h1&gt;12 不等于 12&lt;/h1&gt;&lt;/c:if&gt;</code></pre><p>iii.<code>&lt;c:choose&gt; &lt;c:when&gt; &lt;c:otherwise&gt;</code>标签</p><pre><code>&lt;%-- iii.&lt;c:choose&gt; &lt;c:when&gt; &lt;c:otherwise&gt;标签作用：多路判断。跟 switch ... case .... default 非常接近 choose 标签开始选择判断 when 标签表示每一种判断情况       test 属性表示当前这种判断情况的值 otherwise 标签表示剩下的情况 &lt;c:choose&gt; &lt;c:when&gt; &lt;c:otherwise&gt;标签使用时需要注意的点：     1、标签里不能使用 html 注释，要使用 jsp 注释     2、when 标签的父标签一定要是 choose 标签 --%&gt; &lt;%      request.setAttribute("height", 180); %&gt;&lt;c:choose&gt; &lt;%-- 这是 html 注释 --%&gt; &lt;c:when test="${ requestScope.height &gt; 190 }"&gt;             &lt;h2&gt;小巨人&lt;/h2&gt; &lt;/c:when&gt; &lt;c:when test="${  requestScope.height &gt; 180 }"&gt;&lt;h2&gt;很高&lt;/h2&gt;&lt;/c:when&gt; &lt;c:when test="${ requestScope.height &gt; 170 }"&gt;&lt;h2&gt;还可以&lt;/h2&gt;&lt;/c:when&gt;&lt;c:otherwise&gt;     &lt;c:choose&gt;      &lt;c:when test="${requestScope.height &gt; 160}"&gt;      &lt;h3&gt;大于 160&lt;/h3&gt;      &lt;/c:when&gt;     &lt;c:when test="${requestScope.height &gt; 150}"&gt;      &lt;h3&gt;大于 150&lt;/h3&gt;      &lt;/c:when&gt;     &lt;c:when test="${requestScope.height &gt; 140}"&gt;     &lt;h3&gt;大于 140&lt;/h3&gt;     &lt;/c:when&gt;      &lt;c:otherwise&gt;     其他小于 140      &lt;/c:otherwise&gt;      &lt;/c:choose&gt;      &lt;/c:otherwise&gt;      &lt;/c:choose&gt;</code></pre><p>iv.<code>&lt;c:forEach /&gt;</code></p><p>作用：遍历输出使用。</p><p><strong>1.</strong> <strong>遍历</strong> <strong>1</strong> <strong>到</strong> 10，输出</p><pre><code>&lt;%--1.遍历 1 到 10，输出     begin 属性设置开始的索引    end 属性设置结束的索引     var 属性表示循环的变量(也是当前正在遍历到的数据)     for (int i = 1; i &lt; 10; i++)     --%&gt;     &lt;table border="1"&gt;     &lt;c:forEach begin="1" end="10" var="i"&gt;     &lt;tr&gt;    &lt;td&gt;    第${i}行    &lt;/td&gt;     &lt;/tr&gt;     &lt;/c:forEach&gt;     &lt;/table&gt;</code></pre><p><strong>2.</strong> <strong>遍历</strong> <strong>Object</strong> <strong>数组</strong> </p><pre><code>&lt;%-- 2.遍历 Object 数组        for (Object item: arr)       items 表示遍历的数据源（遍历的集合）       var 表示当前遍历到的数据        --%&gt;        &lt;%       request.setAttribute("arr", new String[]{"18610541354","18688886666","18699998888"});       %&gt;       &lt;c:forEach items="${ requestScope.arr }" var="item"&gt;        ${ item } &lt;br&gt;        &lt;/c:forEach&gt;</code></pre><p><strong>3.</strong> <strong>遍历</strong> <strong>Map</strong> <strong>集合</strong></p><pre><code>&lt;%** Map&lt;String,Object&gt; map = **new** HashMap&lt;String, Object&gt;(); map.put(**"key1"**, **"value1"**); map.put(**"key2"**, **"value2"**); map.put(**"key3"**, **"value3"**); *//* *for ( Map.Entry&lt;String,Object&gt; entry : map.entrySet()) {* *//* *}* request.setAttribute(**"map"**, map); **%&gt;**&lt;**c****:forEach** **items****="****${** requestScope.map **}****"** **var****="entry"**&gt; &lt;**h1**&gt;**${**entry.key**}** = **${**entry.value**}**&lt;/**h1**&gt; &lt;/**c****:forEach**&gt;</code></pre><p><strong>4.</strong> <strong>遍历</strong> <strong>List</strong> <strong>集合**</strong>—list** <strong>中存放</strong> <strong>Student</strong> <strong>类，有属性：编号，用户名，密码，年龄，</strong> </p><p><strong>电话信息</strong></p><pre><code>Student 类： **public class** Student { *//4.**编号，用户名，密码，年龄，电话信息* **private** Integer **id**; **private** String **username**; **private** String **password**; **private** Integer **age**; **private** String **phone**;</code></pre><pre><code>&lt;%--4.**遍历* *List* *集合**---list* *中存放* *Student* *类，有属性：编号，用户名，密码，年龄，电话信息**--%&gt;* **&lt;%** List&lt;Student&gt; studentList = **new** ArrayList&lt;Student&gt;(); **for** (**int** i = 1; i &lt;= 10; i++) { studentList.add(**new** Student(i,**"username"**+i ,**"pass"**+i,18+i,**"phone"**+i)); }request.setAttribute(**"stus"**, studentList); **%&gt;**&lt;table&gt; &lt;**tr**&gt;&lt;**th**&gt;编号&lt;/**th**&gt; &lt;**th**&gt;用户名&lt;/**th**&gt; &lt;**th**&gt;密码&lt;/**th**&gt; &lt;**th**&gt;年龄&lt;/**th**&gt; &lt;**th**&gt;电话&lt;/**th**&gt; &lt;**th**&gt;操作&lt;/**th**&gt; &lt;/**tr**&gt; *&lt;%--**items* *表示遍历的集合* *var* *表示遍历到的数据* *begin* *表示遍历的开始索引值* *end* *表示结束的索引值* *step* *属性表示遍历的步长值* *varStatus* *属性表示当前遍历到的数据的状态* *for**（**int i = 1; i &lt; 10; i+=2**）* *--%&gt;* &lt;**c****:forEach** **begin****="2"** **end****="7"** **step****="2"** **varStatus****="status"** **items****="****${**requestScope.stus**}****"** **var****="stu"**&gt; &lt;**tr**&gt;&lt;**td**&gt;**${**stu.id**}**&lt;/**td**&gt; &lt;**td**&gt;**${**stu.username**}**&lt;/**td**&gt; &lt;**td**&gt;**${**stu.password**}**&lt;/**td**&gt; &lt;**td**&gt;**${**stu.age**}**&lt;/**td**&gt; &lt;**td**&gt;**${**stu.phone**}**&lt;/**td**&gt; &lt;**td**&gt;**${**status.step**}**&lt;/**td**&gt; &lt;/**tr**&gt; &lt;/**c****:forEach**&gt; &lt;/**table**&gt;</code></pre><h2 id="文件的上传"><a href="#文件的上传" class="headerlink" title="文件的上传"></a>文件的上传</h2><p>文件的上传和下载，是非常常见的功能，很多的系统中，或者软件中经常使用文件的上传和下载。</p><h3 id="1-文件的上传介绍"><a href="#1-文件的上传介绍" class="headerlink" title="1.文件的上传介绍"></a>1.文件的上传介绍</h3><p>1.要有一个form标签，method=post请求</p><p>2.form标签的encType属性值必须为multipart/form-data值</p><p>3.在form标签中只用input type=file添加上传的文件</p><p>4.编写服务器代码（servlet）接收，处理上传数据</p><p>encType=multipart/form-data 表示提交的数据，以多段的形式进行拼接。然后以二进制流的形式发送给服务器</p><img src="/2020/06/12/Javaweb/1.PNG" alt="Javawe" style="zoom:200%;"><p><strong>第一步，就是需要导入两个</strong> <strong>jar</strong> <strong>包：</strong> </p><p>commons-fileupload-1.2.1.jar </p><p>commons-io-1.4.jar</p><p><strong>commons-fileupload.jar</strong> <strong>和</strong> <strong>commons-io.jar</strong> <strong>包中，我们常用的类有哪些？</strong> </p><p>ServletFileUpload 类，用于解析上传的数据。 </p><p>FileItem 类，表示每一个表单项。 </p><pre><code>boolean ServletFileUpload.*isMultipartContent*(HttpServletRequest request); </code></pre><p>判断当前上传的数据格式是否是多段的格式。 </p><pre><code>public List&lt;FileItem&gt; parseRequest(HttpServletRequest request) </code></pre><p>解析上传的数据 </p><pre><code>boolean FileItem.isFormField() </code></pre><p>判断当前这个表单项，是否是普通的表单项。还是上传的文件类型。 </p><p>true 表示普通类型的表单项 </p><p>false 表示上传的文件类型 </p><pre><code>String FileItem.getFieldName() </code></pre><p>获取表单项的 name 属性值</p><pre><code>String FileItem.getString() </code></pre><p>获取当前表单项的值。 </p><pre><code>String FileItem.getName(); </code></pre><p>获取上传的文件名 </p><pre><code>void FileItem.write( file ); </code></pre><p>将上传的文件写到 参数 file 所指向抽硬盘位置 。 </p><p>1.3、fileupload  类库的使用：</p><p>上传文件的表单：</p><pre><code>&lt;form action="http://192.168.31.74:8080/09_EL_JSTL/uploadServlet" method="post" enctype="multipart/form-data"&gt; 用户名：&lt;input type="text" name="username" /&gt; &lt;br&gt; 头像：&lt;input type="file" name="photo" &gt; &lt;br&gt; &lt;input type="submit" value="上传"&gt; &lt;/form&gt;</code></pre><p>解析上传的数据的代码： </p><pre><code>/*** 用来处理上传的数据 * @param req * @param resp * @throws ServletException * @throws IOException */@Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //1 先判断上传的数据是否多段数据（只有是多段的数据，才是文件上传的）             if (ServletFileUpload.isMultipartContent(req)) {     // 创建 FileItemFactory 工厂实现类              FileItemFactory fileItemFactory = new DiskFileItemFactory();            // 创建用于解析上传数据的工具类 ServletFileUpload 类          ServletFileUpload servletFileUpload = new ServletFileUpload(fileItemFactory);    try {    // 解析上传的数据，得到每一个表单项   FileItem List&lt;FileItem&gt; list = servletFileUpload.parseRequest(req); // 循环判断，每一个表单项，是普通类型，还是上传的文件      for (FileItem fileItem : list) {     if (fileItem.isFormField()) {// 普通表单项 System.out.println("表单项的 name 属性值：" + fileItem.getFieldName()); // 参数 UTF-8.解决乱码问题 System.out.println("表单项的 value 属性值：" + fileItem.getString("UTF-8")); } else { // 上传的文件 System.out.println("表单项的 name 属性值：" + fileItem.getFieldName()); System.out.println("上传的文件名：" + fileItem.getName()); fileItem.write(new File("e:\\" + fileItem.getName()));}}} catch (Exception e) { e.printStackTrace(); }}}</code></pre><h2 id="文件的下载"><a href="#文件的下载" class="headerlink" title="文件的下载"></a>文件的下载</h2><p><strong>下载的常用</strong> <strong>API</strong> <strong>说明：</strong> </p><p>response.getOutputStream(); </p><p>servletContext.getResourceAsStream(); </p><p>servletContext.getMimeType(); </p><p>response.setContentType(); </p><p>response.setHeader(“Content-Disposition”, “attachment; fileName=1.jpg”); </p><p>这个响应头告诉浏览器。这是需要下载的。而 attachment 表示附件，也就是下载的一个文件。fileName=后面， </p><p>表示下载的文件名。 </p><p>完成上面的两个步骤，下载文件是没问题了。但是如果我们要下载的文件是中文名的话。你会发现，下载无法正确 </p><p>显示出正确的中文名。 </p><p>原因是在响应头中，不能包含有中文字符，只能包含 ASCII 码。文件下载示例：</p><pre><code>@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 1、获取要下载的文件名 String downloadFileName = "2.jpg";// 2、读取要下载的文件内容 (通过 ServletContext 对象可以读取) ServletContext servletContext = getServletContext();// 获取要下载的文件类型String mimeType = servletContext.getMimeType("/file/" + downloadFileName);System.out.println("下载的文件类型：" + mimeType); // 4、在回传前，通过响应头告诉客户端返回的数据类型 resp.setContentType(mimeType); // 5、还要告诉客户端收到的数据是用于下载使用（还是使用响应头） // Content-Disposition 响应头，表示收到的数据怎么处理 // attachment 表示附件，表示下载使用 // filename= 表示指定下载的文件名 resp.setHeader("Content-Disposition", "attachment; filename=" + downloadFileName); /*** /斜杠被服务器解析表示地址为 http://ip:prot/工程名/ 映射 到代码的 Web 目录 */ InputStream resourceAsStream = servletContext.getResourceAsStream("/file/" + downloadFileName); // 获取响应的输出流OutputStream outputStream = resp.getOutputStream(); // 3、把下载的文件内容回传给客户端 // 读取输入流中全部的数据，复制给输出流，输出给客户端 IOUtils.copy(resourceAsStream,outputStream); }</code></pre><p><strong>附件中文名乱码问题解决方案：</strong> </p><p><strong>方案一：**</strong>URLEncoder** <strong>解决</strong> <strong>IE</strong> <strong>和谷歌浏览器的 附件中</strong> </p><p><strong>文名问题。</strong> </p><p>如果客户端浏览器是 IE 浏览器 或者 是谷歌浏览器。我们需要使用 URLEncoder 类先对中文名进行 UTF-8 的编码 </p><p>操作。</p><p>因为 IE 浏览器和谷歌浏览器收到含有编码后的字符串后会以 UTF-8 字符集进行解码显示。 </p><p>// 把中文名进行 UTF-8 编码操作。 </p><p>String str = “attachment; fileName=” + URLEncoder.<em>encode</em>(“中文.jpg”, “UTF-8”);// 然后把编码后的字符串设置到响应头中 </p><p>response.setHeader(“Content-Disposition”, str); </p><p>方案二：BASE64 <strong>编解码 解决 火狐浏览器的附件中文名问</strong> 题</p><p>如果客户端浏览器是火狐浏览器。 那么我们需要对中文名进行 BASE64 的编码操作。 </p><p>这时候需要把请求头 Content-Disposition: attachment; filename=中文名 </p><p>编码成为：Content-Disposition: attachment; filename==?charset?B?xxxxx?= </p><p>=?charset?B?xxxxx?= 现在我们对这段内容进行一下说明。 </p><p>=? </p><p>表示编码内容的开始 </p><p>charset </p><p>表示字符集 </p><p>B </p><p>表示 BASE64 编码 </p><p>xxxx </p><p>表示文件名 BASE64 编码后的内容 </p><p>?= </p><p>表示编码内容的结束 </p><p><strong>BASE64</strong> <strong>编解码操作：</strong> </p><pre><code>public static void main(String[] args) throws Exception { String content = "这是需要 Base64 编码的内容"; // 创建一个 Base64 编码器BASE64Encoder base64Encoder = new BASE64Encoder(); // 执行 Base64 编码操作 String encodedString = base64Encoder.encode(content.getBytes("UTF-8")); System.out.println( encodedString ); // 创建 Base64 解码器 BASE64Decoder base64Decoder = new BASE64Decoder(); // 解码操作 byte[] bytes = base64Decoder.decodeBuffer(encodedString); String str = new String(bytes, "UTF-8"); System.out.println(str); }</code></pre><p><strong>因为火狐使用的是</strong> <strong>BASE64</strong> <strong>的编解码方式还原响应中的汉字。所以需要使用</strong> <strong>BASE64Encoder</strong> <strong>类进行编码操作</strong></p><pre><code>// 使用下面的格式进行 BASE64 编码后String str = "attachment; fileName=" + "=?utf-8?B?" + new BASE64Encoder().encode("中文.jpg".getBytes("utf-8")) + "?="; // 设置到响应头中 response.setHeader("Content-Disposition", str);</code></pre><p>那么我们如何解决上面两种不同编解码方式呢。我们只需要通过判断请求头中 User-Agent 这个请求头携带过来的 </p><p>浏览器信息即可判断出是什么浏览器。 </p><p>如下： </p><pre><code>String ua = request.getHeader("User-Agent"); // 判断是否是火狐浏览器if (ua.contains("Firefox")) {// 使用下面的格式进行 BASE64 编码后 String str = "attachment; fileName=" + "=?utf-8?B?" + new BASE64Encoder().encode("中文.jpg".getBytes("utf-8")) + "?="; // 设置到响应头中 response.setHeader("Content-Disposition", str); } else {// 把中文名进行 UTF-8 编码操作。String str = "attachment; fileName=" + URLEncoder.encode("中文.jpg", "UTF-8"); // 然后把编码后的字符串设置到响应头中 response.setHeader("Content-Disposition", str); }</code></pre><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>1.cookie是服务器通知客户端保存键值对的一种技术</p><p>2.客户端有了cookie后，每次请求都发送给服务器</p><p>3.每个Cookie的大小不能超过4kb</p><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><h2 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h2><p>JSON (JavaScript Object Notation) 是一种轻量级的数据交换格式。 易于人阅读和编写。同时也易于机器解析 和生成。 它基于 JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999 的一 个子集。 JSON 采用完全独立于语言的文本格式，但是也使用了类似于 C 语言家族的习惯（包括 C, C++, C#, Java, JavaScript, Perl, Python 等）。 这些特性使 JSON 成为理想的数据交换语言。</p><p>json 是一种轻量级的数据交换格式。 </p><p>轻量级指的是跟 xml 做比较。 </p><p>数据交换指的是客户端和服务器之间业务数据的传递格式</p><h3 id="Json在JavaScript中的使用"><a href="#Json在JavaScript中的使用" class="headerlink" title="Json在JavaScript中的使用"></a>Json在JavaScript中的使用</h3><p>json 是由键值对组成，并且由花括号（大括号）包围。每个键由引号引起来，键和值之间使用冒号进行分隔， </p><p>多组键值对之间进行逗号进行分隔。 </p><p>json 定义示例：</p><pre><code>var jsonObj = {"key1":12, "key2":"abc", "key3":true, "key4":[11,"arr",false],"key5":{ "key5_1" : 551, "key5_2" : "key5_2_value" },"key6":[{ "key6_1_1":6611, "key6_1_2":"key6_1_2_value"},{"key6_2_1":6621, "key6_2_2":"key6_2_2_value" }] };</code></pre><h3 id="json-的访问"><a href="#json-的访问" class="headerlink" title="json 的访问"></a>json 的访问</h3><p>json 本身是一个对象。 </p><p>json 中的 key 我们可以理解为是对象中的一个属性。 </p><p>json 中的 key 访问就跟访问对象的属性一样： json 对象.key </p><p>json 访问示例：</p><pre><code>alert(typeof(jsonObj));// object json 就是一个对象 alert(jsonObj.key1); //12 alert(jsonObj.key2); // abc alert(jsonObj.key3); // true alert(jsonObj.key4);// 得到数组[11,"arr",false] // json 中 数组值的遍历 for(var i = 0; i &lt; jsonObj.key4.length; i++) { alert(jsonObj.key4[i]); }alert(jsonObj.key5.key5_1);//551 alert(jsonObj.key5.key5_2);//key5_2_value alert( jsonObj.key6 );// 得到 json 数组 // 取出来每一个元素都是 json 对象 var jsonItem = jsonObj.key6[0]; // alert( jsonItem.key6_1_1 ); //6611 alert( jsonItem.key6_1_2 );</code></pre><h3 id="json-的两个常用方法"><a href="#json-的两个常用方法" class="headerlink" title="json 的两个常用方法"></a>json <strong>的两个常用方法</strong></h3><p>json 的存在有两种形式。 </p><p>一种是：对象的形式存在，我们叫它 json 对象。 </p><p>一种是：字符串的形式存在，我们叫它 json 字符串。 </p><p>一般我们要操作 json 中的数据的时候，需要 json 对象的格式。 </p><p>一般我们要在客户端和服务器之间进行数据交换的时候，使用 json 字符串。 </p><p>JSON.stringify() </p><p>把 json 对象转换成为 json 字符串 </p><p>JSON.parse() </p><p>把 json 字符串转换成为 json 对象示例代码： </p><pre><code>// 把 json 对象转换成为 json 字符串 var jsonObjString = JSON.stringify(jsonObj); // 特别像 Java 中对象的 toString alert(jsonObjString) // 把 json 字符串。转换成为 json 对象 var jsonObj2 = JSON.parse(jsonObjString); alert(jsonObj2.key1);// 12 alert(jsonObj2.key2);// abc</code></pre><h3 id="JSON-在-java-中的使用"><a href="#JSON-在-java-中的使用" class="headerlink" title="JSON 在 java 中的使用"></a>JSON <strong>在</strong> <strong>java</strong> <strong>中的使用</strong></h3><h4 id="javaBean-和-json的互转"><a href="#javaBean-和-json的互转" class="headerlink" title="javaBean 和 json的互转"></a>javaBean 和 json的互转</h4><pre><code>@Test public void test1(){Person person = new Person(1,"国哥好帅!"); // 创建 Gson 对象实例 Gson gson = new Gson(); // toJson 方法可以把 java 对象转换成为 json 字符串 String personJsonString = gson.toJson(person);System.out.println(personJsonString); // fromJson 把 json 字符串转换回 Java 对象 // 第一个参数是 json 字符串 // 第二个参数是转换回去的 Java 对象类型 Person person1 = gson.fromJson(personJsonString, Person.class); S</code></pre><h4 id="List-和-json-的互转"><a href="#List-和-json-的互转" class="headerlink" title="List 和 json 的互转"></a>List 和 <strong>json</strong> 的互转</h4><pre><code>// 1.2.2、List 和 json 的互转 @Test public void test2() { List&lt;Person&gt; personList = new ArrayList&lt;&gt;();personList.add(new Person(1, "国哥"));personList.add(new Person(2, "康师傅")); Gson gson = new Gson(); // 把 List 转换为 json 字符串 String personListJsonString = gson.toJson(personList);System.out.println(personListJsonString);List&lt;Person&gt; list = gson.fromJson(personListJsonString, new PersonListType().getType());System.out.println(list); Person person = list.get(0); System.out.println(person); }</code></pre><h4 id="map-和-json-的互转"><a href="#map-和-json-的互转" class="headerlink" title="map 和 json 的互转"></a>map <strong>和</strong> json 的互转</h4><pre><code>// 1.2.3、map 和 json 的互转@Test public void test3(){Map&lt;Integer,Person&gt; personMap = new HashMap&lt;&gt;();personMap.put(1, new Person(1, "国哥好帅")); personMap.put(2, new Person(2, "康师傅也好帅")); Gson gson = new Gson(); // 把 map 集合转换成为 json 字符串 String personMapJsonString = gson.toJson(personMap); System.out.println(personMapJsonString); // Map&lt;Integer,Person&gt; personMap2 = gson.fromJson(personMapJsonString, new PersonMapType().getType()); Map&lt;Integer,Person&gt; personMap2 = gson.fromJson(personMapJsonString, new TypeToken&lt;HashMap&lt;Integer,Person&gt;&gt;(){}.getType()); System.out.println(personMap2); Person p = personMap2.get(1); System.out.println(p); }</code></pre><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><h3 id="2-1、什么是-AJAX-请求"><a href="#2-1、什么是-AJAX-请求" class="headerlink" title="2.1、什么是 AJAX 请求"></a>2.1、什么是 <strong>AJAX</strong> <strong>请求</strong></h3><p>AJAX 即Asynchronous    JavascriptA<em>**nd</em> **XML（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发 </p><p>技术。</p><p>ajax 是一种浏览器通过 js 异步发起请求，局部更新页面的技术。 </p><p>Ajax 请求的局部更新，浏览器地址栏不会发生变化 </p><p>局部更新不会舍弃原来页面的内容</p><h3 id="2-2、原生AJAX请求的示例："><a href="#2-2、原生AJAX请求的示例：" class="headerlink" title="2.2、原生AJAX请求的示例："></a>2.2、原生AJAX请求的示例：</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Javaweb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javaweb </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
